#!/usr/bin/env python3
"""
FrameWorkers 环境安装脚本。
运行即创建 conda 环境并安装所有依赖。

    python install_requirements.py
"""

import os
import re
import subprocess
import sys
from collections import defaultdict
from pathlib import Path

ENV_NAME = "frameworkers"
PYTHON_VERSION = "3.11"
SKIP_DIRS = {"node_modules", "__pycache__", ".git", ".venv", "venv", "env"}
OUTPUT_FILE = "requirements.txt"


def find_requirements_files() -> list[Path]:
    root = Path(".").resolve()
    results = []
    for req_file in root.rglob("requirements.txt"):
        if req_file.resolve() == (root / OUTPUT_FILE).resolve():
            continue
        if any(part in SKIP_DIRS for part in req_file.parts):
            continue
        results.append(req_file)
    return sorted(results)


def parse_requirements(file_path: Path) -> list[str]:
    reqs = []
    with open(file_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            reqs.append(line)
    return reqs


def _pkg_name(req: str) -> str:
    m = re.match(r"^([A-Za-z0-9_][A-Za-z0-9._-]*)", req)
    return m.group(1).lower().replace("-", "_") if m else req.lower()


def merge_requirements(files: list[Path]) -> list[str]:
    merged: dict[str, str] = {}
    for fpath in files:
        for req in parse_requirements(fpath):
            pkg = _pkg_name(req)
            if pkg not in merged:
                merged[pkg] = req
            elif ">=" in req and "==" in merged[pkg]:
                merged[pkg] = req
    return list(merged.values())


def generate_requirements_txt(files: list[Path]):
    """Regenerate the unified requirements.txt from sub-directories."""
    root = Path(".").resolve()
    by_source: dict[str, list[str]] = defaultdict(list)
    seen: dict[str, str] = {}

    for fpath in files:
        rel = os.path.relpath(fpath, root)
        for req in parse_requirements(fpath):
            pkg = _pkg_name(req)
            if pkg not in seen:
                seen[pkg] = rel
                by_source[rel].append(req)
            elif ">=" in req and "==" in seen.get(pkg, ""):
                by_source[seen[pkg]] = [r for r in by_source[seen[pkg]] if _pkg_name(r) != pkg]
                seen[pkg] = rel
                by_source[rel].append(req)

    lines = [
        "# Auto-generated by install_requirements.py — do not edit manually.",
        "# Re-generate:  python install_requirements.py --generate",
        "",
    ]
    for source_rel in sorted(by_source):
        lines.append(f"# From {source_rel}")
        for req in sorted(by_source[source_rel]):
            lines.append(req)
        lines.append("")

    out_path = root / OUTPUT_FILE
    out_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"Wrote {out_path}")


def main() -> int:
    if "--generate" in sys.argv:
        files = find_requirements_files()
        if not files:
            print("No sub-directory requirements.txt found.")
            return 1
        generate_requirements_txt(files)
        return 0

    files = find_requirements_files()
    if not files:
        print("No sub-directory requirements.txt found.")
        return 1

    reqs = merge_requirements(files)
    print(f"Collected {len(reqs)} packages from {len(files)} sub-directories.")

    print(f"\nCreating conda env '{ENV_NAME}' (python={PYTHON_VERSION}) …")
    try:
        subprocess.run(
            ["conda", "create", "-n", ENV_NAME, f"python={PYTHON_VERSION}", "-y"],
            check=True,
        )
    except subprocess.CalledProcessError as exc:
        print(f"conda create failed (exit {exc.returncode})", file=sys.stderr)
        return 1

    print(f"\nInstalling {len(reqs)} packages into '{ENV_NAME}' …")
    try:
        subprocess.run(
            ["conda", "run", "-n", ENV_NAME, "--no-banner", "pip", "install"] + reqs,
            check=True,
        )
    except subprocess.CalledProcessError as exc:
        print(f"pip install failed (exit {exc.returncode})", file=sys.stderr)
        return 1

    print(f"\nDone! Run:\n  conda activate {ENV_NAME}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
